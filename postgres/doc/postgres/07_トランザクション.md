# トランザクション

ACIDを原則とした排他処理

- Atomicity（原始性）
  - 「全部やるか、全部やらないか」という性質
- Consistency（一貫性）
  - 「トランザクションの前後でデータに矛盾を起こさせない」という性質
  - 型システムや制約システムによりテーブルを定義する
  - CS的な制約ではなく、業務制約はアプリ側で頑張れ
- Isolation（分離性・独立性）
  - 「トランザクション宙に行われる操作は他のトランザクションに影響を与えない」という性質
- Durability（永続性）
  - コミットさ記録されたデータが停電などの障害でも失われない性質
  - トランザクションログが残るので、そのログを食わせれば復旧前に戻すことができる。

## メリット・デメリット

銀行のデータだと、正確性が何よりも大事なのでトランザクションの利用が必須に思える。  
残高データが1円でも異なっていれば問題なので、書き込みはもちろん読み込みでも正確なデータが返ってこなければならない。

対して、Facebookのデータなどは別に正確性が何かに寄与している訳でもない。  
いいねデータが1つ異なっていたぐらいでは世界はどうにもならないし、君の人生もどうにもならない。  
多少正確性に難はあるが、スムーズにデータが取り出せるような構成が好ましいだろう。

## トランザクション分離レベル

トランザクションの分離性・独立性については、いくつかの選択肢が与えられている。  
では、他のトランザクションに影響を与えない性質ということではあるが、どんな影響が考えられるのか？

- 参考
  - [トランザクション分離レベルについてのまとめ](https://qiita.com/song_ss/items/38e514b05e9dabae3bdb)

### 発生する問題

|分離レベル|Dirty Read|Fuzzy Read|Phantom Read|
|:--|:--:|:--:|:--:|
|READ UNCOMMITTED|〇|〇|〇|
|READ COMMITTED|×|〇|〇|
|REPEATABLE READ|×|×|〇|
|SERIALIZABLE|×|×|×|

> PostgreSQLは`READ UNCOMMITTED`と`READ COMMITTED`が同じ扱いである。  
> InnoDBは`REPEATABLE READ`でも`Phantom Read`は発生しない

#### Dirty Read

別トランザクションの未コミット処理が読み取れる問題。

- 【前提】
  - トランザクションAとトランザクションBが同時に展開されている。
  - トランザクションBでデータ変更処理を行う。（コミットはしない）
- 【結果】
  - トランザクションBの未コミット処理がトランザクションAで読み取れてしまう。

#### Fuzzy Read / Non-Repeatable Read

Dirty Readが未コミット処理を読み取ってしまう問題だとすれば、  
Fuzzy Readはコミット済処理を読み取ってしまう問題である。

- 【前提】
  - トランザクションAとトランザクションBが同時に展開されている。
  - トランザクションBでデータを更新したコミットを行うとする。
- 【結果】
  - トランザクションBのコミット済処理がトランザクションAで読み取れてしまう。

> Non-Repeatableは非再現の意味

#### Phantom Read

- 【前提】
  - トランザクションAとトランザクションBが同時に展開されている。
  - Aで一定範囲のレコードに対して処理を行っている途中で、Bでデータを追加・削除をコミットする。
- 【結論】
  - 幻影のようにBのデータが反映されるため、Aの結果が異なる

#### Serialization Anomaly

### レベルの種類

- [READ UNCOMMITTED](./トランザクション分離レベル/07-1_READ_UNCOMMITTED.md)
- [READ COMMITTED](./トランザクション分離レベル/07-2_READ_COMMITTED.md)
- [REPEATABLE READ](./トランザクション分離レベル/07-3_REPEATABL_READ.md)
- [SERIALIZABLE](./トランザクション分離レベル/07-4_SERIALIZABLE.md)
